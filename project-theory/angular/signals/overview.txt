*) refer user.list.component.ts

*) A signal is a wrapper around a value that notifies interested consumers when that value changes. Signals can contain any value, from primitives to complex data structures.
   You read a signal's value by calling its getter function, which allows Angular to track where the signal is used.
   Signals may be either writable or read-only.

*) Writable signals - 
    onst count = signal(0);
// Signals are getter functions - calling them reads their value.
console.log('The count is: ' + count());
count.set(3);

*) Computed signal are read-only signals that derive their value from other signals.
   const count: WritableSignal<number> = signal(0);
   const doubleCount: Signal<number> = computed(() => count() * 2);
   doubleCount.set(3); // this can not be writable

*) Only the signals actually read during the derivation are tracked. For example, in this computed the count signal is only read if the showCount signal is true:

const showCount = signal(false);
const count = signal(0);
const conditionalCount = computed(() => {
  if (showCount()) {
    return `The count is ${count()}.`;
  } else {
    return 'Nothing to see here!';
  }
});
check
When you read conditionalCount, if showCount is false the "Nothing to see here!" message is returned without reading the count signal. This means that if you later update count it will not result in a recomputation of conditionalCount.
If you set showCount to true and then read conditionalCount again, the derivation will re-execute and take the branch where showCount is true, returning the message which shows the value of count. Changing count will then invalidate conditionalCount's cached value.

*) Signals are useful because they notify interested consumers when they change. An effect is an operation that runs whenever one or more signal values change. You can create an effect with the effect function:

effect(() => {
  console.log(`The current count is: ${count()}`);
});
usage - Logging data being displayed and when it changes, either for analytics or as a debugging tool.
Keeping data in sync with window.localStorage.
Adding custom DOM behavior that can't be expressed with template syntax.
Performing custom rendering to a <canvas>, charting library, or other third party UI library.

*) constructor() {
    // Register a new effect.
    effect(() => {
      console.log(`The count is: ${this.count()}`);
    });
  }
  or outside constructor
    initializeLogging(): void {
    effect(() => {
      console.log(`The count is: ${this.count()}`);
    }, {injector: this.injector});
  }

*) 




